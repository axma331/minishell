Резюме: Цель этого проекта - создать простую оболочку. Да, ваш opeмаленький bash или zsh. Вы узнаете много нового о процессах и файловых дескрипторах.
Разрешенные функции:
readline,
rl_clear_history,
rl_on_new_line,
rl_replace_ilne,
rl_redisplay,
add_history,
printf,
malloc,
free,
write,
open,
read,
close,
    fork,
    wait,
    waitpid,
    wait3,
    wait4,
    signal,
    kill,
exit,
    ,
    chdir,
stat,
lstat,
fstat,
unlink,
    execve,
    dup,
    dup2,
    pipe,
opendir,
readdir,
closedir,
strerror,
perror,
isatty,
ttyname,
ttyslot,
ioctl,
getenv,
tcsetattr,
tcgetattr,
tgetent,
tgetflag,
tgetnum,
tgetstr,
tgoto,
tputs

Написать оболочку:
Ваша оболочка должна:
• Не интерпретировать незакрытые кавычки или неопределенные специальные символы, такие как \ или;.
• Не использовать более одной глобальной переменной, подумайте об этом и будьте готовы объяснить, почему вы это делаете.
• Показывать подсказку при ожидании новой команды.
• Иметь рабочую Историю.
• Искать и запускать нужный исполняемый файл (на основе переменной PATH или используя относительный или абсолютный путь).
Он должен реализовывать встроенные функции:
◦ эхо с опцией-n
◦ cd с только относительным или абсолютным путем ◦ pwd без опций
◦ экспорт без опций
◦ не установлено без каких-либо опций
◦ env без опций или аргументов
◦ выход без вариантов
• "запретить любую интерпретацию последовательности символов.
• " запретить любую интерпретацию последовательности символов, кроме $.
• Перенаправление:
◦ < следует перенаправить ввод.
◦ > следует перенаправить вывод.
◦ “<<” считывайте входные данные из текущего источника, пока не появится строка, содержащая только разделитель. ему не нужно обновлять историю!
◦ “>>” следует перенаправить вывод в режиме добавления.
• Каналы | Вывод каждой команды в конвейере соединяется через канал с
входом следующей команды.
• Переменные среды ( $ , за которыми следуют символы) должны расширяться до своих значений.
• $? должно расширяться до состояния выхода последнего выполненного конвейера переднего плана.
• ctrl-C ctrl-D ctrl-\ должно работать как в bash.
• В интерактивном режиме:
◦ ctrl-C напечатать новое приглашение в новой строке.
◦ ctrl-D выйдите из оболочки.
◦ ctrl-\ ничего не делать.
функция readline может привести к некоторой утечке, которую вам не нужно исправлять. Но будьте осторожны, ваш собственный код не должен приводить к утечкам.
Вы должны ограничиться описанием предмета.
Ничего не спрашиваемого не требуется.
По каждому пункту, если у вас есть какие-либо сомнения, возьмите bash в качестве ориентира.

Бонусная часть
• Если Обязательная часть не идеальна, даже не думайте о бонусах•&&, | | со скобками для приоритетов.
• подстановочный знак * должен работать для текущего рабочего каталога.



igSmile> kjdfg dmfjgkj dfg > jdhfb | jdh djhfg
kjdfg dmfjgkj dfg > jdhfb | jdh djhfg
args[0] = kjdfg             
args[1] = dmfjgkj
args[2] = dfg
cmd->count_args:3
cmd->redir[0]:  0
cmd->redir[1]:  1
cmd->pipe:      1
cmd->infile:    (null)
cmd->outfile:   jdhfb
args[0] = jdh
args[1] = djhfg
cmd->count_args:2
cmd->redir[0]:  0
cmd->redir[1]:  0
cmd->pipe:      0
cmd->infile:    (null)
cmd->outfile:   (null)
bigSmile> 